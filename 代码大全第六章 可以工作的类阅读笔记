6.1ADT
1.使用ADT的好处（纯get/set接口有何好处？）
 1）可以隐藏实现细节（在纯get/set接口内无效，没用的封装，可访问性一样的高）
 2）修改时只需要改动函数内部，不会影响其他地方
 3）更容易提高性能（其实就是提高性能时不用到处改代码，同2）
 4）让程序的正确性更显而易见（比起可能写错数值，写错变量名形参名等，ADT只可能写错函数名）
 5）更具说明性（比宏更好，省去计算与或等的理解成本）
 6）无需在程序内部传递数据
 7）抽象出现实世界中的实体
 
2.什么应该成为ADT
   常见的底层数据类型（比如attrblock中各种神奇字典列表）
   文件（操作系统提供第一层ADT,高层语言提供第二层ADT）
   简单事物（没想到能产生联系的例子）
   
3在非面向对象环境中 用ADT处理多分数据实例。如何获取实例？
  1）给每个实例都标一个编号，然后在调用ADT服务子程序时，传id进去遍历查询（如GetObject）
  2）设定ADT所需要的数据类型，然后传给每一个ADT服务子程序（没想到例子）
  3）使用隐藏实例。即设置当前实例为xxx（如SetGlobalManager）
  
6.2

对类接口未做好评估和分割时，即时类整体表现成一种良好的抽象，类内子程序也未必有良好的抽象
使用容器也应该被抽象隐藏
修改接口应该关注它所暴露出的抽象是否被改变
不要添加与类抽象层次不一致的公用接口（python如何做到抽象层次一致？靠规范和不断组合？）
关注接口表现的抽象比关注类的内聚性更有助于深入的理解设计！！（确实！）

良好的封装（python一大痛点）

1.尽可能地限制类和成员的可访问性，采用哪种方式最能保护接口抽象的完整性
2.不要暴露成员数据（python炸裂，就算把 int x 变成int GetX()，也只能从规范上规定不能直接访问数据，没法从设计上规避使用者这么用）
3.避免把private的细节混入到类的接口中（不应鼓励使用者查阅细节，然而项目代码是你不查细节你就得死），（惯用做法是把private内容全部封装起来，用一个指针指向m_Implementation）
4.不应对类的使用者做出任何假设（那args咋办？）
5.如果一个类提供了一套不完整的服务，使用者就要去直接读写该类的内部数据。封装性就没了

语义上的封装（可以说在项目代码里完全不存在了）
举个例子：不去调用Init因为知道doxxx里会自动执行它，使用Class A.m_Max而不使用Class B.m_Max因为知道这两个是完全一样的

xx开发，或者主程，就是要在项目迭代周期，以及代码抽象性上作权衡取舍，然后定准则，作为显而易见的经验传授下去(好像有点要求太高
